# 第１章 学習メモ
## 1.1 プログラミングの要素

### 1.1.5 手続き適用の置換モデル
#### 正規順序評価 (normal-order evaluation)
完全に展開（+などの基本演算子だけにする）してから計算する

#### 適用順序評価 (applicative-order evaluation) 
引数を評価してから適用する

### 1.1.7 例: ニュートン法による平方根
- schemeにはfor文などない！でも繰り返し処理は書ける。

#### 練習問題 1.6
多分、適用順序評価のせいで無限に評価が行われている。

#### 練習問題 1.7
テキストにはgood-enough?は、小さい数値の平方根を求めるには効率的でなく（計算に非常に時間がかかる？）、大きい数値の平方根については不適切なテストになる（正確な値が得られない？）というようなことが書いてあった。しかし、実際にテストしてみると小さい数値の平方根の値が正確ではなく、大きい数値の平方根の計算が終わらなかった。もしかすると、小さい/大きいが逆なのかもしれない。

自分で作った改良good-enough?については、よく動作していると思う。

### 1.1.8 ブラックボックス抽象化としての手続き
good-enough?手続きをsquareを使って定義するときに、square手続きはブラックボックスとみなせる。
squareは二乗にするという手続きを抽象化したもの（＝手続き抽象、procedural abstraction）である。
このとき実装は気にしていない。

#### 局所名
仮引数の名前はなんでもいい。(square x)のxと(good-enough? guess x)のxは別のxである。
xは手続きの本体に局所化されているので、(square x)のxと(good-enough? guess x)のxが混同されることはない。

仮引数は、束縛変数(bound variable)と呼ばれる。手続きは仮引数を束縛(bind)している。
束縛変数は束縛している手続き本体をスコープ(scope)として持っている。

<, -, absは仮引数ではないから自由変数。

#### 内部定義とブロック構造
sqrtのユーザーはsqrtという手続きだけに関心を持つが、good-enough?、improveなどが実際には使われている。
もし今、別の手続きに使う用のgood-enough?を定義したくても、sqrt用に定義されているのでできない。
そのため、プライベートなgood-enough?を定義したい。
ブロック構造を使えば、それが可能になる。

ブロック構造にすると、(sqrt x)のxはsqrtに束縛されているので、good-enough?, improve, sqrt-iterでxをそのまま使うことができ、より単純に書くことができる。