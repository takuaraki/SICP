# 第１章 学習メモ
## 1.1 プログラミングの要素

### 1.1.5 手続き適用の置換モデル
#### 正規順序評価 (normal-order evaluation)
完全に展開（+などの基本演算子だけにする）してから計算する

#### 適用順序評価 (applicative-order evaluation) 
引数を評価してから適用する

### 1.1.7 例: ニュートン法による平方根
- schemeにはfor文などない！でも繰り返し処理は書ける。

#### 練習問題 1.6
多分、適用順序評価のせいで無限に評価が行われている。

#### 練習問題 1.7
テキストにはgood-enough?は、小さい数値の平方根を求めるには効率的でなく（計算に非常に時間がかかる？）、大きい数値の平方根については不適切なテストになる（正確な値が得られない？）というようなことが書いてあった。しかし、実際にテストしてみると小さい数値の平方根の値が正確ではなく、大きい数値の平方根の計算が終わらなかった。もしかすると、小さい/大きいが逆なのかもしれない。

自分で作った改良good-enough?については、よく動作していると思う。

### 1.1.8 ブラックボックス抽象化としての手続き
good-enough?手続きをsquareを使って定義するときに、square手続きはブラックボックスとみなせる。
squareは二乗にするという手続きを抽象化したもの（＝手続き抽象、procedural abstraction）である。
このとき実装は気にしていない。

#### 局所名
仮引数の名前はなんでもいい。(square x)のxと(good-enough? guess x)のxは別のxである。
xは手続きの本体に局所化されているので、(square x)のxと(good-enough? guess x)のxが混同されることはない。

仮引数は、束縛変数(bound variable)と呼ばれる。手続きは仮引数を束縛(bind)している。
束縛変数は束縛している手続き本体をスコープ(scope)として持っている。

<, -, absは仮引数ではないから自由変数。

#### 内部定義とブロック構造
sqrtのユーザーはsqrtという手続きだけに関心を持つが、good-enough?、improveなどが実際には使われている。
もし今、別の手続きに使う用のgood-enough?を定義したくても、sqrt用に定義されているのでできない。
そのため、プライベートなgood-enough?を定義したい。
ブロック構造を使えば、それが可能になる。

ブロック構造にすると、(sqrt x)のxはsqrtに束縛されているので、good-enough?, improve, sqrt-iterでxをそのまま使うことができ、より単純に書くことができる。

## 1.2 手続きおよび手続きが生成するプロセス
手続きは、計算プロセスの局所展開(local evolution)のためのパターンである。
この節では、プロセスの一般的な”形”について見ていく。

### 1.2.1 線形再帰と反復
nの階乗を求める手続きを例に考えていく。

#### 再帰プロセス(recursive process)
手続きを展開していき、展開が終わったら縮約していく。展開は、プロセスが遅延演算(deferred operation)
の連鎖を構築する際に起こる。

後で実行する演算を記録しておく必要がある。階乗の計算では、情報量がnに比例して増加していく。
また、ステップ数もnに比例して増加する。このようなプロセスは、線形再帰プロセス(linear recursive process)
と呼ばれる。

#### 反復プロセス(iterative process)
生成すべき値(product)、カウンター(counter)、どこまで計算するか(max-count)の三つの値だけ記録しておけばいい。
ここで使われる変数product, counter, max-countは、状態変数(state variable)と呼ばれる。
反復プロセスは、状態の更新規則と終了テストからなる。

nの階乗の計算では、プロセス数はnに比例して増加する。このようなプロセスは、
線形反復プロセス(linear iterative process)と呼ばれる。

#### 再帰手続き(procedure)と再帰プロセス(process)の違い
- 再帰手続き：手続きの定義がその手続き自体を参照している書き方がされている。構文の問題。
- 再帰プロセス：手続きを展開したのち、縮約していく。

「fact-iterは再帰手続きであり、反復プロセスである。」という言い方ができる。

一般的な言語（C言語とか）では、反復的な処理を再帰手続きで書くと、手続き呼び出し回数だけメモリを消費してしまう、
つまり再帰プロセスとして処理されてしまう。
そのため、C言語などで反復手続きを記述するには専用のループ構造（for, whileなど）に頼る必要がある。
Schemeには、この欠点はない！Schemeでは、再帰手続きとして記述していても固定の空間で実行できる（メモリ消費が増えない）。この性質を持った実装は末尾再帰(tail-recursive)と呼ばれる。

#### 練習問題 1.9
2種類の方法で定義された+のプロセスが、再帰か反復かを答える問題。前者が再帰プロセスで、後者が反復プロセスと思われる。
定義内で呼び出している自分以外の手続き（手続きAとする）の引数に自分自身を入れている場合、
引数である自分自身が評価される→自分の中で手続きAを呼び出す→引数である自分自身が評価される→...という処理になるため、
再帰プロセスになるっぽい。

#### 練習問題 1.10
アッカーマン関数と呼ばれる再帰プロセスの手続きに関する問題。

- f(n) = 2n
- g(n) = 2^n （2のn乗）
- h(n) = 2^(2^(2^(2^(...)))) （2の(2の(2の(2の(...)乗)乗)乗)乗）
