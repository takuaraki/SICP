## 1.2 手続きおよび手続きが生成するプロセス
手続きは、計算プロセスの局所展開(local evolution)のためのパターンである。
この節では、プロセスの一般的な”形”について見ていく。

### 1.2.1 線形再帰と反復
nの階乗を求める手続きを例に考えていく。

#### 再帰プロセス(recursive process)
手続きを展開していき、展開が終わったら縮約していく。展開は、プロセスが遅延演算(deferred operation)
の連鎖を構築する際に起こる。

後で実行する演算を記録しておく必要がある。階乗の計算では、情報量がnに比例して増加していく。
また、ステップ数もnに比例して増加する。このようなプロセスは、線形再帰プロセス(linear recursive process)
と呼ばれる。

#### 反復プロセス(iterative process)
生成すべき値(product)、カウンター(counter)、どこまで計算するか(max-count)の三つの値だけ記録しておけばいい。
ここで使われる変数product, counter, max-countは、状態変数(state variable)と呼ばれる。
反復プロセスは、状態の更新規則と終了テストからなる。

nの階乗の計算では、プロセス数はnに比例して増加する。このようなプロセスは、
線形反復プロセス(linear iterative process)と呼ばれる。

#### 再帰手続き(procedure)と再帰プロセス(process)の違い
- 再帰手続き：手続きの定義がその手続き自体を参照している書き方がされている。構文の問題。
- 再帰プロセス：手続きを展開したのち、縮約していく。

「fact-iterは再帰手続きであり、反復プロセスである。」という言い方ができる。

一般的な言語（C言語とか）では、反復的な処理を再帰手続きで書くと、手続き呼び出し回数だけメモリを消費してしまう、
つまり再帰プロセスとして処理されてしまう。
そのため、C言語などで反復手続きを記述するには専用のループ構造（for, whileなど）に頼る必要がある。
Schemeには、この欠点はない！Schemeでは、再帰手続きとして記述していても固定の空間で実行できる（メモリ消費が増えない）。この性質を持った実装は末尾再帰(tail-recursive)と呼ばれる。

#### 練習問題 1.9
2種類の方法で定義された+のプロセスが、再帰か反復かを答える問題。前者が再帰プロセスで、後者が反復プロセスと思われる。
定義内で呼び出している自分以外の手続き（手続きAとする）の引数に自分自身を入れている場合、
引数である自分自身が評価される→自分の中で手続きAを呼び出す→引数である自分自身が評価される→...という処理になるため、
再帰プロセスになるっぽい。

#### 練習問題 1.10
アッカーマン関数と呼ばれる再帰プロセスの手続きに関する問題。

- f(n) = 2n
- g(n) = 2^n （2のn乗）
- h(n) = 2^(2^(2^(2^(...)))) （2の(2の(2の(2の(...)乗)乗)乗)乗）
