# 1.2 手続きおよび手続きが生成するプロセス
手続きは、計算プロセスの局所展開(local evolution)のためのパターンである。
この節では、プロセスの一般的な”形”について見ていく。

## 1.2.1 線形再帰と反復
nの階乗を求める手続きを例に考えていく。

### 再帰プロセス(recursive process)
手続きを展開していき、展開が終わったら縮約していく。展開は、プロセスが遅延演算(deferred operation)
の連鎖を構築する際に起こる。

後で実行する演算を記録しておく必要がある。階乗の計算では、情報量がnに比例して増加していく。
また、ステップ数もnに比例して増加する。このようなプロセスは、線形再帰プロセス(linear recursive process)
と呼ばれる。

### 反復プロセス(iterative process)
生成すべき値(product)、カウンター(counter)、どこまで計算するか(max-count)の三つの値だけ記録しておけばいい。
ここで使われる変数product, counter, max-countは、状態変数(state variable)と呼ばれる。
反復プロセスは、状態の更新規則と終了テストからなる。

nの階乗の計算では、プロセス数はnに比例して増加する。このようなプロセスは、
線形反復プロセス(linear iterative process)と呼ばれる。

### 再帰手続き(procedure)と再帰プロセス(process)の違い
- 再帰手続き：手続きの定義がその手続き自体を参照している書き方がされている。構文の問題。
- 再帰プロセス：手続きを展開したのち、縮約していく。

「fact-iterは再帰手続きであり、反復プロセスである。」という言い方ができる。

一般的な言語（C言語とか）では、反復的な処理を再帰手続きで書くと、手続き呼び出し回数だけメモリを消費してしまう、
つまり再帰プロセスとして処理されてしまう。
そのため、C言語などで反復手続きを記述するには専用のループ構造（for, whileなど）に頼る必要がある。
Schemeには、この欠点はない！Schemeでは、再帰手続きとして記述していても固定の空間で実行できる（メモリ消費が増えない）。この性質を持った実装は末尾再帰(tail-recursive)と呼ばれる。

### 練習問題 1.9
2種類の方法で定義された+のプロセスが、再帰か反復かを答える問題。前者が再帰プロセスで、後者が反復プロセスと思われる。
定義内で呼び出している自分以外の手続き（手続きAとする）の引数に自分自身を入れている場合、
引数である自分自身が評価される→自分の中で手続きAを呼び出す→引数である自分自身が評価される→...という処理になるため、
再帰プロセスになるっぽい。

### 練習問題 1.10
アッカーマン関数と呼ばれる再帰プロセスの手続きに関する問題。

- f(n) = 2n
- g(n) = 2^n （2のn乗）
- h(n) = 2^(2^(2^(2^(...)))) （2の(2の(2の(2の(...)乗)乗)乗)乗）

## 1.2.2 木の再帰(tree recursion)
フィボナッチ数列の計算を例に考える。
再帰プロセスで書くと以下のようになる。

```
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
```

この手続きは非常に効率が悪い。この手続きがfib(0)やfib(1)を計算する回数はfib(n+1)となる。
つまり計算量はフィボナッチ数の大きさとともに増加していく。フィボナッチ数は指数的に増加するので、
計算量も指数的に増加していく。
一方、必要な空間はnに対して線形にしか増加しない。
一般に、木の再帰プロセスで必要なステップ数は木のノード数に比例し、必要な空間は木の深さに比例する。

反復プロセスで書く場合、aとbという値を保持し、a<-a+b, b<-a をn回繰り返せばよい。
そうすれば、a=fib(n+1), b=fib(n) となる。このことをschemeで書くと以下のようになる。
```
(define (fib n)
  (define (fib-iter a b count)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1))))
  (fib-iter 1 0 n))
```
この手続きのステップ数はnに比例した増加となる。

木の再帰プロセスの手続きは、数学の定義をそのままSchemeに書き起こしたようなものであり、わかりやすいが効率は悪い。
反復プロセスは効率が良いが、三つの状態変数を使った反復で書けることに気がつく必要がある。

_\* 数学的定義をプログラムに書きおこすのが最善とは限らないというのは面白いと思った。_

### 例：両替パターンの計算
フィボナッチ数の計算より複雑な問題として、1ドルを両替するやり方がいくつあるかという問題を例に考える。
使うのは50, 25, 10, 5, 1セント。

n種類のコインを使って金額aを両替するやり方のパターン数は、以下の合計である。
- 一つ目の種類のコイン以外のすべての種類のコインを使って金額aを両替するパターン数
- n種類の全てのコインを使って、a-dを両替するパターン数。dは一つ目のコインの額面。

_\* 一つ目の種類のコインを1枚使った場合と1枚も使わなかった場合が排反だから真？_

また、基本的なルールとして
- aが0なら、パターン数は1
- aが0未満、またはnが0ならパターン数は0

以上のことをschemeで書くと以下のようになる。

```lisp
(define (count-change amount) (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
         ((or (< amount 0) (= kinds-of-coins 0)) 0)
         (else (+ (cc amount (- kinds-of-coins 1)) ; 一つ目の種類のコイン以外のすべての種類のコインを使って金額aを両替するパターン数
                  (cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins))))) ; n種類の全てのコインを使って、a-dを両替するパターン数。dは一つ目のコインの額面。
(define (first-denomination kinds-of-coins) ; 1つ目のコインの額面
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
```
count-changeはfibの一つ目と同じく冗長な木の再帰プロセスだが、理解はしやすい。

### 練習問題 1.11
ある関数fを再帰プロセスと反復プロセスで書く問題。

再帰プロセスは、定義をただ単にscheme形式に書き起こすだけ。

```lisp
(define (f n)
  (if (< n 3)
      n
      (+ (f (- n 1))
         (* 2 (f (- n 2)))
         (* 3 (f (- n 3))))))
```

反復プロセスは、係数が状態変数として使えるということに気がついたら書けた。
たとえば、f(6)を計算する時には以下のような状態変化をしていると考えることができる。

```
f(6) = f(5) + 2f(4) + 3f(3)
     = 3f(4) + 5f(3) + 3f(2)
     = 8f(3) + 9f(2) + 9f(1)
     = 17f(2) + 25f(1) + 24f(0)
     = 2 * 17 + 1 * 25 + 0 * 24
     = 59
```

ここで重要なのが、見えている全ての式を評価（展開）しないこと。
具体的に言うと、`f(5) + 2f(4) + 3f(3)`から状態変化する時は`f(5)`のみを展開するようにし、
`3f(4) + 5f(3) + 3f(2)`から状態変化する時は`f(4)`のみを展開するようにする。
そうすれば、`a*f(n) + b*f(n-1) + c*f(n-2)`という形を保ったまま展開できる。

ここでa, b, cは1回の状態変化でそれぞれ`a<-a+b, b<-2*a+c, c<-3*a`と変化する状態変数だと考えられる。
また、評価回数は6の場合は4回、5の場合は3回、... 、3の場合は1回なのでn-2回評価すれば良い。
評価が終わった状態は、`a*f(2) + b*f(1) + c*f(0)`なので、結果としては`2*a + 1*b + 0*c`を出力すれば良い。

したがって、反復プロセスの手続きは以下のように書くことができる。

```lisp
(define (f-iter a b c count)
  (if (= count 0)
      (+ (* 2 a) (* 1 b) (* 0 c))
      (f-iter (+ a b) (+ (* 2 a) c) (* 3 a) (- count 1))))

(define (f n)
  (if (< n 3)
      n
      (f-iter 1 0 0 (- n 2))))
```

### 練習問題 1.12
パスカルの三角形の要素を求める手続きを再帰プロセスで書く問題。
パスカルの三角形の外側は0、辺は1、内部はその上にある2つの数値の合計、
という定義を数式で書くと以下のようになると考えた。
ここで、rowは三角形の上から何段目かを表し、colは左から何番目かを表す。

```
pascal(row, col) = 0    if (col < 1) or (row < 0) or (row < col)
pascal(row, col) = 1    if (col = 1) or (row = col)
pascal(row, col) = pascal(row-1, col-1) + pascal(row-1, col)    otherwise
```

この定義をschemeに書き起こすと以下のようになった。

```lisp
(define (pascal row col)
  (cond ((or (< row 1) (< col 1) (< row col)) 0)
        ((or (= col 1) (= row col)) 1)
        (else (+ (pascal (- row 1) (- col 1)) (pascal (- row 1) col)))))
```

### 練習問題 1.13
なぜか数学の証明問題が出てきた。n番目のフィボナッチ数に関する問題。
まずは、ヒントにあった`Fib(n)=(phi^n - psi^n)/sqrt(5)`を示す。

n=0, 1, 2の場合
```
Fib(0) = (phi^0 - psi^0)/sqrt(5) = 0
Fib(1) = (phi^1 - psi^1)/sqrt(5) = 1
Fib(2) = (phi^2 - psi^2)/sqrt(5) = 1
```
となるので、成り立っている。ここで、0以上の整数nについて
```
Fib(n) = (phi^n - psi^n)/sqrt(5)
Fib(n+1) = (phi^(n+1) - psi^(n+1))/sqrt(5)
```
が成り立つと仮定すると、
```
Fib(n+2) = Fib(n+1) + Fib(n)
         = (phi^(n+1) + phi^n - psi^(n+1) - psi^n) / sqrt(5)
         = {phi^(n+2)(phi^(-1) + phi(-2)) - psi^(n+2)(psi^(-1) + psi(-2))} / sqrt(5)
```
となる。`phi^(-1) + phi(-2)`と`psi^(-1) + psi(-2)`を計算するとどちらも1となるので、
```
Fib(n+2) = (phi^(n+2) - psi^(n+2))/sqrt(5)
```
である。以上の議論から帰納的に
```
Fib(n) = (phi^n - psi^n)/sqrt(5)
```
が示される。よって、
```
abs(Fib(n) - (phi^n)/sqrt(5)) = abs(-psi^n) / sqrt(5)
```
`abs(psi) < 1`、`sqrt(5) > 2`ということを考慮すると、
```
abs(Fib(n) - (phi^n)/sqrt(5)) = abs(-psi^n) / sqrt(5) < 1/2
```
よって、`Fib(n)`は`(phi^n)/sqrt(5))`に最も近い整数である。

## 1.2.3 増加オーダー (order of growth)
任意の十分大きなnに対して、nと独立なせいの定数k1とk2が存在し、
`k1f(n) <= R(n) <= k2f(n)`を満たすとき、R(n)は増加オーダーが
Θ(f(n))であるという。

たとえば、ステップ数がnに比例する場合はR(n)=Θ(n)、
木の再帰によるフィボナッチ数の計算はΘ(phi^n)のステップ数と
Θ(n)の空間を必要とする。

### 練習問題 1.14
とりあえず、紙に11セント両替の木を書いてみたが、かなり長くなった。
深さは16。11+5=16ということだと思う。
ステップ数は、数えてない。多分、指数的な感じで爆発的に増加するのだと思う。

### 練習問題 1.15
`(sine 12.15)`は以下のように展開される。
```lisp
(sine 12.15)
(p (sine 4.05))
(p (p (sine 1.35)))
(p (p (p (sine 0.45))))
```
よって、`(sine 12.15)`を評価する際はpが3回適用されている。

`(sine a)`が評価される際、pが1回適用されて終了しない場合、
次のpの引数は`(/ a 3.0)`となる。もし、引数に3aが来たとすると、次のpの引数はaとなる。
つまり、aが3倍になるたびにpの適用回数、すなわちステップ数が1増えると考えられる。
よって、ステップ数はa/3と考えらえるのでオーダーはΘ(a)である。

木の深さもpの適用回数だと思ったので、空間の増加オーダーもΘ(a)だと思う。

## 1.2.4 指数計算
指数計算を線形再帰プロセスで書くと以下のようになる。
```lisp
linear recursive process
(define (expt b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))
```

また、線形反復プロセスで書くと以下のようになる。
```lisp
(define (expt b n)
  (expt-iter b n 1))
(define (expt-iter b counter product)
  (if (= counter 0)
      product
      (expt-iter b (- counter 1) (* b product))))
```

さらに、次の規則
```
b^n = (b^(n/2))^2    if n is even
b^n = b*b^(n-1)      if n is odd
```

を用いて書いた再帰プロセスは以下のようになる。
```lisp
(define (fast-expt b n)
  (cond ((= n 0) 1)
        ((even? n) (square (fast-expt b (/ n 2))))
        (else (* b (fast-expt b (- n 1))))))
(define (square n) (* n n))
(define (even? n)
  (= (remainder n 2) 0))
```
b^2nの計算はb^nの計算より、1回だけ多い。このことから、
このプロセスは空間・ステップ数ともにnに対して対数的に増加するということがわかる。
これは、線形オーダーのプロセスと比較して、大きいnに対して非常に強力である。

### 練習問題 1.16
`(b^(n/2))^2 = (b^2)^(n/2)`を利用して、指数計算を定義する問題。
`a*b^n`が不変になるように状態変化をさせる。自分の解答は以下。

```lisp
(define (expt-iter b n a)
  (cond ((= n 0) a)
        ((even? n) (expt-iter (square b) (/ n 2) a))
        (else (expt-iter b (- n 1) (* a b)))))
        
(define (expt b n)
  (expt-iter b n 1))
```
たとえば、bの14乗を計算する場合、(square b) -> b^2とすれば、
```
(expt b 14)
(expt-iter b 14 1)
(expt-iter b^2 7 1)
(expt-iter b^2 6 b^2)
(expt-iter b^4 3 b^2)
(expt-iter b^4 2 b^6)
(expt-iter b^8 1 b^6)
(expt-iter b^8 0 b^14)
b^14
```
と状態変化していく。式で書くと、
```
b^14 = (b^2)^7 * 1
     = (b^2)^6 * b^2
     = (b^4)^3 * b^2
     = (b^4)^2 * b^6
     = (b^8)^1 * b^6
     = (b^8)^0 * b^14
```
という変形をしていると考えられる。
