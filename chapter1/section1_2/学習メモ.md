# 1.2 手続きおよび手続きが生成するプロセス
手続きは、計算プロセスの局所展開(local evolution)のためのパターンである。
この節では、プロセスの一般的な”形”について見ていく。

## 1.2.1 線形再帰と反復
nの階乗を求める手続きを例に考えていく。

### 再帰プロセス(recursive process)
手続きを展開していき、展開が終わったら縮約していく。展開は、プロセスが遅延演算(deferred operation)
の連鎖を構築する際に起こる。

後で実行する演算を記録しておく必要がある。階乗の計算では、情報量がnに比例して増加していく。
また、ステップ数もnに比例して増加する。このようなプロセスは、線形再帰プロセス(linear recursive process)
と呼ばれる。

### 反復プロセス(iterative process)
生成すべき値(product)、カウンター(counter)、どこまで計算するか(max-count)の三つの値だけ記録しておけばいい。
ここで使われる変数product, counter, max-countは、状態変数(state variable)と呼ばれる。
反復プロセスは、状態の更新規則と終了テストからなる。

nの階乗の計算では、プロセス数はnに比例して増加する。このようなプロセスは、
線形反復プロセス(linear iterative process)と呼ばれる。

### 再帰手続き(procedure)と再帰プロセス(process)の違い
- 再帰手続き：手続きの定義がその手続き自体を参照している書き方がされている。構文の問題。
- 再帰プロセス：手続きを展開したのち、縮約していく。

「fact-iterは再帰手続きであり、反復プロセスである。」という言い方ができる。

一般的な言語（C言語とか）では、反復的な処理を再帰手続きで書くと、手続き呼び出し回数だけメモリを消費してしまう、
つまり再帰プロセスとして処理されてしまう。
そのため、C言語などで反復手続きを記述するには専用のループ構造（for, whileなど）に頼る必要がある。
Schemeには、この欠点はない！Schemeでは、再帰手続きとして記述していても固定の空間で実行できる（メモリ消費が増えない）。この性質を持った実装は末尾再帰(tail-recursive)と呼ばれる。

### 練習問題 1.9
2種類の方法で定義された+のプロセスが、再帰か反復かを答える問題。前者が再帰プロセスで、後者が反復プロセスと思われる。
定義内で呼び出している自分以外の手続き（手続きAとする）の引数に自分自身を入れている場合、
引数である自分自身が評価される→自分の中で手続きAを呼び出す→引数である自分自身が評価される→...という処理になるため、
再帰プロセスになるっぽい。

### 練習問題 1.10
アッカーマン関数と呼ばれる再帰プロセスの手続きに関する問題。

- f(n) = 2n
- g(n) = 2^n （2のn乗）
- h(n) = 2^(2^(2^(2^(...)))) （2の(2の(2の(2の(...)乗)乗)乗)乗）

## 1.2.2 木の再帰(tree recursion)
フィボナッチ数列の計算を例に考える。
再帰プロセスで書くと以下のようになる。

```
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
```

この手続きは非常に効率が悪い。この手続きがfib(0)やfib(1)を計算する回数はfib(n+1)となる。
つまり計算量はフィボナッチ数の大きさとともに増加していく。フィボナッチ数は指数的に増加するので、
計算量も指数的に増加していく。
一方、必要な空間はnに対して線形にしか増加しない。
一般に、木の再帰プロセスで必要なステップ数は木のノード数に比例し、必要な空間は木の深さに比例する。

反復プロセスで書く場合、aとbという値を保持し、a<-a+b, b<-a をn回繰り返せばよい。
そうすれば、a=fib(n+1), b=fib(n) となる。このことをschemeで書くと以下のようになる。
```
(define (fib n)
  (define (fib-iter a b count)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1))))
  (fib-iter 1 0 n))
```
この手続きのステップ数はnに比例した増加となる。

木の再帰プロセスの手続きは、数学の定義をそのままSchemeに書き起こしたようなものであり、わかりやすいが効率は悪い。
反復プロセスは効率が良いが、三つの状態変数を使った反復で書けることに気がつく必要がある。

_ \* 数学的定義をプログラムに書きおこすのが最善とは限らないというのは面白いと思った。 _

### 例：両替パターンの計算
フィボナッチ数の計算より複雑な問題として、1ドルを両替するやり方がいくつあるかという問題を例に考える。
使うのは50, 25, 10, 5, 1セント。

n種類のコインを使って金額aを両替するやり方のパターン数は、以下の合計である。
- 一つ目の種類のコイン以外のすべての種類のコインを使って金額aを両替するパターン数
- n種類の全てのコインを使って、a-dを両替するパターン数。dは一つ目のコインの額面。

_ \* 一つ目の種類のコインを1枚使った場合と1枚も使わなかった場合が排反だから真？_

また、基本的なルールとして
- aが0なら、パターン数は1
- aが0未満、またはnが0ならパターン数は0

以上のことをschemeで書くと以下のようになる。

```
(define (count-change amount) (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
         ((or (< amount 0) (= kinds-of-coins 0)) 0)
         (else (+ (cc amount (- kinds-of-coins 1)) ; 一つ目の種類のコイン以外のすべての種類のコインを使って金額aを両替するパターン数
                  (cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins))))) ; n種類の全てのコインを使って、a-dを両替するパターン数。dは一つ目のコインの額面。
(define (first-denomination kinds-of-coins) ; 1つ目のコインの額面
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
```
count-changeはfibの一つ目と同じく冗長な木の再帰プロセスだが、理解はしやすい。
